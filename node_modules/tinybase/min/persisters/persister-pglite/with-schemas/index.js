const a=a=>typeof a,t="tinybase",e=",",n=a(""),s=Promise,i=a=>null==a,o=(a,t,e)=>i(a)?e?.():t(a),r=t=>a(t)==n,c=a=>Array.isArray(a),E=(a,t,e)=>a.slice(t,e),l=a=>a.length,w=async a=>s.all(a),y=a=>{throw Error(a)},d=(a,t)=>a.forEach(t),u=(a,t="")=>a.join(t),T=(a,t)=>a.map(t),R=a=>0==l(a),A=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),g=a=>a.shift(),p=(a,t)=>a?.has(t)??!1,C=a=>i(a)||0==(a=>a?.size??0)(a),O=a=>[...a?.values()??[]],L=(a,t)=>a?.forEach(t),$=(a,t)=>a?.delete(t),v=Object,I=a=>v.getPrototypeOf(a),S=v.entries,m=v.keys,_=v.freeze,h=(a=[])=>v.fromEntries(a),f=(...a)=>v.assign({},...a),b=(a,t)=>(delete a[t],a),D=(a,t)=>T(S(a),(([a,e])=>t(e,a))),P=(a,t)=>h(D(a,((a,e)=>[e,t(a,e)]))),U=a=>v.values(a),F=a=>l(m(a)),M=a=>(a=>!i(a)&&o(I(a),(a=>a==v.prototype||i(I(a))),(()=>!0)))(a)&&0==F(a),G=JSON.stringify,B=JSON.parse,j="_",x="_id",X="SELECT",Y="WHERE",q="TABLE",H="ALTER "+q,W="DELETE FROM",k=X+"*FROM",z=a=>`"${a.replace(/"/g,'""')}"`,J=(a,t=[1])=>u(T(a,(()=>"$"+t[0]++)),e),K=a=>new Map(a),V=(a,t)=>a?.get(t),Q=(a,t)=>T([...a?.entries()??[]],(([a,e])=>t(e,a))),Z=(a,t,e)=>i(e)?($(a,t),a):a?.set(t,e),aa=(a,t,e,n)=>(p(a,t)?n?.(V(a,t)):Z(a,t,e()),V(a,t)),ta=(a,t,e,n,s=0)=>o((e?aa:V)(a,t[s],s>l(t)-2?e:K),(i=>{if(s>l(t)-2)return n?.(i)&&Z(a,t[s]),i;const o=ta(i,t,e,n,s+1);return C(i)&&Z(a,t[s]),o})),ea=a=>new Set(c(a)||i(a)?a:[a]),na=(a,t)=>a?.add(t),sa="ColumnName",ia="store",oa="json",ra=ia+"TableName",ca=ia+"Id"+sa,Ea=ia+sa,la="autoLoadIntervalSeconds",wa="rowId"+sa,ya="tableId",da="tableName",ua="deleteEmptyColumns",Ta="deleteEmptyTable",Ra={mode:oa,[la]:1},Aa={load:0,save:0,[da]:t+"_values"},Na=(a,t,e,n,s)=>{const o=K();return P(a,((a,c)=>{const l=E(U(f(t,r(a)?{[e]:a}:a)),0,F(t));i(l[0])||n(c,l[0])||(s(c,l[0]),Z(o,c,l))})),o},ga=/^\d+$/,pa=K(),Ca=K(),Oa=(a,t,e,n,s,r,E,w={},u=0,T=[])=>{let R,A,p,O=0,v=0,I=0;aa(pa,T,(()=>0)),aa(Ca,T,(()=>[]));const S=K(),[m,h,f,b,D]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!M(a)||!M(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!M(a)||!M(t),t.setContent]:y("Store type not supported by this Persister"))(E,a,u),[P,U,F]=(()=>{let a;const[t,e]=(()=>{const a=[];let t=0;return[e=>(e?g(a):null)??""+t++,t=>{ga.test(t)&&l(a)<1e3&&N(a,t)}]})(),n=K();return[(e,s,i,o=[],r=()=>[])=>{a??=H;const c=t(1);return Z(n,c,[e,s,i,o,r]),na(ta(s,i??[""],ea),c),c},(t,e,...s)=>d(((a,t=[""])=>{const e=[],n=(a,s)=>s==l(t)?N(e,a):null===t[s]?L(a,(a=>n(a,s+1))):d([t[s],null],(t=>n(V(a,t),s+1)));return n(a,0),e})(t,e),(t=>L(t,(t=>V(n,t)[0](a,...e??[],...s))))),a=>o(V(n,a),(([,t,s])=>(ta(t,s??[""],void 0,(t=>($(t,a),C(t)?1:0))),Z(n,a),e(a),s))),t=>o(V(n,t),(([t,,e=[],n,s])=>{const o=(...r)=>{const c=l(r);c==l(e)?t(a,...r,...s(r)):i(e[c])?d(n[c]?.(...r)??[],(a=>o(...r,a))):o(...r,e[c])};o()}))]})(),G=a=>{a!=O&&(O=a,U(S,void 0,O))},B=t=>{(m&&c(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},j=async a=>(2!=O&&(G(1),v++,await q((async()=>{try{const e=await t();c(e)?B(e):a?D(a):y("Content is not an array: "+e)}catch(t){r?.(t),a&&D(a)}G(0)}))),H),x=()=>(A&&(s(A),A=void 0),H),X=async a=>(1!=O&&(G(2),I++,await q((async()=>{try{await e(h,a)}catch(a){r?.(a)}G(0)}))),H),Y=()=>(p&&(a.delListener(p),p=void 0),H),q=async(...a)=>(N(V(Ca,T),...a),await(async()=>{if(!V(pa,T)){for(Z(pa,T,1);!i(R=g(V(Ca,T)));)try{await R()}catch(a){r?.(a)}Z(pa,T,0)}})(),H),H={load:j,startAutoLoad:async a=>{x(),await j(a);try{A=await n((async(a,t)=>{t||a?2!=O&&(G(1),v++,B(t??a),G(0)):await j()}))}catch(a){r?.(a)}return H},stopAutoLoad:x,isAutoLoading:()=>!i(A),save:X,startAutoSave:async()=>(Y(),await X(),p=a.addDidFinishTransactionListener((()=>{const a=f();b(a)&&X(a)})),H),stopAutoSave:Y,isAutoSaving:()=>!i(p),getStatus:()=>O,addStatusListener:a=>P(a,S),delListener:t=>(F(t),a),schedule:q,getStore:()=>a,destroy:()=>(V(Ca,T).splice(0,void 0),x().stopAutoSave()),getStats:()=>({loads:v,saves:I}),...w};return _(H)},La=(a,t,n,s,o,r=$a,c,E)=>{const l=K();return[async()=>{l.clear(),T(await n(a,t),(({tn:a,cn:t})=>na(aa(l,a,ea),t)))},async(t,e)=>((a,t)=>p(V(l,a),t))(t,e)?h(A(T(await a(k+z(t)),(a=>[a[e],E?P(b(a,e),E):b(a,e)])),(([a,t])=>!i(a)&&!M(t)))):{},async(t,n,s,E,y,d=!1)=>{const g=ea();P(s??{},(a=>T(m(a??{}),(a=>na(g,a)))));const C=O(g);if(!d&&y&&R(C)&&p(l,t))return await a("DROP "+q+z(t)),void Z(l,t);const L=V(l,t),v=ea(O(L));if(R(C)||(p(l,t)?await w(T([n,...C],(async(e,s)=>{$(v,e)||(await a(H+z(t)+"ADD"+z(e)+o),0==s&&await a("CREATE UNIQUE INDEX pk ON "+z(t)+`(${z(n)})`),na(L,e))}))):(await a("CREATE "+q+z(t)+`(${z(n)}${o} PRIMARY KEY${u(T(C,(a=>e+z(a)+o)))});`),Z(l,t,ea([n,...C])))),await w([...!d&&E?T(O(v),(async e=>{e!=n&&(await a(H+z(t)+"DROP"+z(e)),$(L,e))})):[]]),d)i(s)?await a(W+z(t)+Y+" true"):await w(D(s,(async(e,s)=>{i(e)?await a(W+z(t)+Y+z(n)+"=$1",[s]):R(C)||await r(a,t,n,m(e),{[s]:c?T(U(e),c):U(e)},L)})));else if(R(C))p(l,t)&&await a(W+z(t)+Y+" true");else{const e=A(O(V(l,t)),(a=>a!=n)),i={},o=[];P(s??{},((a,t)=>{i[t]=T(e,(t=>c?c(a?.[t]):a?.[t])),N(o,t)})),await r(a,t,n,e,i),await a(W+z(t)+Y+z(n)+`NOT IN(${J(o)})`,o)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},$a=async(a,t,n,s,i)=>{const o=[1];await a("INSERT INTO"+z(t)+"("+((...a)=>u(T(a,z),e))(n,...s)+")VALUES"+u(D(i,(a=>"($"+o[0]+++","+J(a,o)+")")),e)+"ON CONFLICT("+z(n)+")DO UPDATE SET"+u(T(s,(a=>z(a)+"=excluded."+z(a))),e),D(i,((a,t)=>[t,...T(a,(a=>a??null))])).flat())},va=(a,t,e,n,s,i,o,[r,c,E],l,w,y,d,u,T)=>{const[R,A,N,g]=La(t,l,w,s,u,T),p=Oa(a,(async()=>await g((async()=>{return await R(),a=(await A(r,c))[j]?.[E]??"null",B(a,((a,t)=>"ï¿¼"===t?void 0:t));var a}))),(async a=>await g((async()=>{var t;await R(),await N(r,c,{[j]:{[E]:(t=a()??null,G(t,((a,t)=>void 0===t?"ï¿¼":t)))}},!0,!0)}))),e,n,s,o,{[d]:()=>y,destroy:()=>(p.stopAutoLoad().stopAutoSave(),i(),p)},0,y);return p},Ia=(a,t,e,n,s,o,r,[c,E,[l,y,d]],u,T,R,N,g,p,C,O)=>{const[L,$,v,I]=La(t,u,T,s,g,p,C,O),S=async(a,t)=>await w(Q(E,(async([e,n,s,i],o)=>{t&&!(o in a)||await v(e,n,a[o],s,i,t)}))),m=async(a,t)=>y?await v(d,x,{[j]:a},!0,!0,t):null,_=Oa(a,(async()=>await I((async()=>{await L();const a=await(async()=>h(A(await w(Q(c,(async([a,t],e)=>[a,await $(e,t)]))),(a=>!M(a[1])))))(),t=await(async()=>l?(await $(d,x))[j]:{})();return M(a)&&i(t)?void 0:[a,t]}))),(async(a,t)=>await I((async()=>{if(await L(),i(t)){const[t,e]=a();await S(t),await m(e)}else await S(t[0],!0),await m(t[1],!0)}))),e,n,s,r,{[N]:()=>R,destroy:()=>(_.stopAutoLoad().stopAutoSave(),o(),_)},0,R);return _},Sa=t,ma=/^([cd]:)(.+)/,_a=t+"_data",ha=t+"_table",fa=async(a,e,n,s,i)=>((a,e,n,s,i,c,l,y,d,u,R="getDb")=>{const A=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(n,c),[N,,g,C]=(a=>{const e=(a=>f(Ra,r(a)?{[ra]:a}:a??{}))(a),n=e[la];if(e.mode==oa){const a=e[ra]??t;return[1,n,[a,e[ca]??x,e[Ea]??ia],ea(a)]}const{tables:{load:s={},save:i={}}={},values:o={}}=e,c=E(U(f(Aa,o)),0,F(Aa)),l=c[2],w=ea(l),y=ea(l);return[0,n,[Na(s,{[ya]:null,[wa]:x},ya,(a=>p(y,a)),(a=>na(w,a))),Na(i,{[da]:null,[wa]:x,[ua]:0,[Ta]:0},da,((a,t)=>p(y,t)),((a,t)=>na(w,t))),c],w]})(e),L=async a=>{await A(`CREATE OR REPLACE TRIGGER ${z(_a+"_"+a)} AFTER INSERT OR UPDATE OR DELETE ON ${z(a)} EXECUTE FUNCTION ${_a}()`)};return(N?va:Ia)(a,A,(async a=>{await A(`CREATE OR REPLACE FUNCTION ${ha}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Sa}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${ha} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${ha}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${_a}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Sa}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(T(O(C),(async a=>{await A(`CREATE TABLE IF NOT EXISTS ${z(a)}("_id"text PRIMARY KEY)`),await L(a)}))),await s(Sa,(async t=>{return await o((e=t,n=ma,e?.match(n)),(async([,t,e])=>{p(C,e)&&("c:"==t&&await L(e),a())}));var e,n}))}),i,l,y,d,g,O(C),(async(a,t)=>await a(`${X} table_name tn,column_name cn FROM information_schema.columns ${Y} table_schema='public'AND table_name IN(${J(t)})`,t)),u,R,"text",void 0,(a=>G(a)),(a=>B(a)))})(a,n,(async(a,t=[])=>(await e.query(a,t)).rows),(async(a,t)=>await e.listen(a,t)),(async a=>{try{await a()}catch(a){i?.(a)}}),s,i,(()=>0),3,e,"getPglite");export{fa as createPglitePersister};
