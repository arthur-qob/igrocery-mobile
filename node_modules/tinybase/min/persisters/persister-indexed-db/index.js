const t=Promise,e=globalThis.window,a=clearInterval,n=t=>null==t,s=(t,e,a)=>n(t)?a?.():e(t),r=t=>Array.isArray(t),o=t=>t.length,c=e=>new t(e),i=async e=>t.all(e),l=t=>{throw Error(t)},y=(t,e)=>t.forEach(e),d=(t,e)=>t.map(e),u=(t,...e)=>t.push(...e),g=t=>t.shift(),w=Object,h=t=>w.getPrototypeOf(t),p=w.entries,v=w.keys,S=w.freeze,b=t=>(t=>!n(t)&&s(h(t),(t=>t==w.prototype||n(h(t))),(()=>!0)))(t)&&0==(t=>o(v(t)))(t),A=t=>n(t)||0==(t=>t?.size??0)(t),C=(t,e)=>t?.forEach(e),f=(t,e)=>t?.delete(e),L=t=>new Map(t),D=(t,e)=>t?.get(e),M=(t,e,a)=>n(a)?(f(t,e),t):t?.set(e,a),k=(t,e,a,n)=>{var s,r;return s=t,r=e,s?.has(r)?n?.(D(t,e)):M(t,e,a()),D(t,e)},j=(t,e,a,n,r=0)=>s((a?k:D)(t,e[r],r>o(e)-2?a:L),(s=>{if(r>o(e)-2)return n?.(s)&&M(t,e[r]),s;const c=j(s,e,a,n,r+1);return A(s)&&M(t,e[r]),c})),m=/^\d+$/,x=t=>new Set(r(t)||n(t)?t:[t]),E=L(),P=L(),T=(t,e,a,c,i,d,w,h={},p=0,v=[])=>{let T,B,O,z=0,I=0,$=0;k(E,v,(()=>0)),k(P,v,(()=>[]));const F=L(),[K,N,q,G,H]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!b(t)||!b(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!b(t)||!b(e),e.setContent]:l("Store type not supported by this Persister"))(w,t,p),[J,Q,R]=(()=>{let t;const[e,a]=(()=>{const t=[];let e=0;return[a=>(a?g(t):null)??""+e++,e=>{m.test(e)&&o(t)<1e3&&u(t,e)}]})(),r=L();return[(a,n,s,o=[],c=()=>[])=>{t??=tt;const i=e(1);var l,y;return M(r,i,[a,n,s,o,c]),l=j(n,s??[""],x),y=i,l?.add(y),i},(e,a,...n)=>y(((t,e=[""])=>{const a=[],n=(t,s)=>s==o(e)?u(a,t):null===e[s]?C(t,(t=>n(t,s+1))):y([e[s],null],(e=>n(D(t,e),s+1)));return n(t,0),a})(e,a),(e=>C(e,(e=>D(r,e)[0](t,...a??[],...n))))),t=>s(D(r,t),(([,e,n])=>(j(e,n??[""],void 0,(e=>(f(e,t),A(e)?1:0))),M(r,t),a(t),n))),e=>s(D(r,e),(([e,,a=[],s,r])=>{const c=(...i)=>{const l=o(i);l==o(a)?e(t,...i,...r(i)):n(a[l])?y(s[l]?.(...i)??[],(t=>c(...i,t))):c(...i,a[l])};c()}))]})(),U=t=>{t!=z&&(z=t,Q(F,void 0,z))},V=e=>{(K&&r(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},W=async t=>(2!=z&&(U(1),I++,await _((async()=>{try{const a=await e();r(a)?V(a):t?H(t):l("Content is not an array: "+a)}catch(e){d?.(e),t&&H(t)}U(0)}))),tt),X=()=>(B&&(i(B),B=void 0),tt),Y=async t=>(1!=z&&(U(2),$++,await _((async()=>{try{await a(N,t)}catch(t){d?.(t)}U(0)}))),tt),Z=()=>(O&&(t.delListener(O),O=void 0),tt),_=async(...t)=>(u(D(P,v),...t),await(async()=>{if(!D(E,v)){for(M(E,v,1);!n(T=g(D(P,v)));)try{await T()}catch(t){d?.(t)}M(E,v,0)}})(),tt),tt={load:W,startAutoLoad:async t=>{X(),await W(t);try{B=await c((async(t,e)=>{e||t?2!=z&&(U(1),I++,V(e??t),U(0)):await W()}))}catch(t){d?.(t)}return tt},stopAutoLoad:X,isAutoLoading:()=>!n(B),save:Y,startAutoSave:async()=>(Z(),await Y(),O=t.addDidFinishTransactionListener((()=>{const t=q();G(t)&&Y(t)})),tt),stopAutoSave:Z,isAutoSaving:()=>!n(O),getStatus:()=>z,addStatusListener:t=>J(t,F),delListener:e=>(R(e),t),schedule:_,getStore:()=>t,destroy:()=>(D(P,v).splice(0,void 0),X().stopAutoSave()),getStats:()=>({loads:I,saves:$}),...h};return S(tt)},B=["t","v"],O={keyPath:"k"},z=async(t,e)=>{const a=(e=>d(p(e),(([e,a])=>I(t,"put",{k:e,v:a}))))(e);d(await I(t,"getAllKeys"),(n=>((t,e)=>e in t)(e,n)?0:u(a,I(t,"delete",n)))),await i(a)},I=async(t,e,a)=>c(((n,s)=>{const r=t[e](a);r.onsuccess=()=>n(r.result),r.onerror=()=>s(`objectStore.${e} error`)})),$=(t,n,s=1,r)=>{const o=async(t,a=[],s=0)=>c(((r,o)=>{const c=(e?e.indexedDB:indexedDB).open(n,s?2:void 0);c.onupgradeneeded=()=>s&&d(B,(t=>{try{c.result.createObjectStore(t,O)}catch{}})),c.onsuccess=async()=>{try{const e=c.result.transaction(B,"readwrite"),n=await i(d(B,(async(n,s)=>await t(e.objectStore(n),a[s]))));c.result.close(),r(n)}catch(t){c.result.close(),o(t)}},c.onerror=()=>o("indexedDB.open error")}));return T(t,(async()=>await o((async t=>((t=[])=>w.fromEntries(t))(d(await I(t,"getAll"),(({k:t,v:e})=>[t,e])))))),(async t=>await o((async(t,e)=>await z(t,e)),t(),1)),(t=>setInterval(t,1e3*s)),(t=>a(t)),r,1,{getDbName:()=>n})};export{$ as createIndexedDbPersister,z as objectStoreMatch};
